# 设计模式学习

学习设计模式，重点在于理解类和接口所扮演的“角色”，而不是盯着代码本身。

## 面向对象设计原则

### 单一职责原则

- 定义：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。

- 解读：单一职责原则用来控制类的粒度大小。一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责耦合在一起，当其中一个职责变化时可能会影响其他职责运作，因此需要将这些职责分离。

  **单一职责原则时实现高内聚、低耦合的指导方针**，需要开发人员发现类的不同职责，并将其分离。

### 开闭原则

- 定义：软件实体应当对扩展开放，对修改关闭。

- 解读：开闭原则就是指在软件实体应**尽量在不修改原有代码的情况下进行扩展**。

  如果一个软件设计符合开闭原则，那么在扩展时无须修改现有代码，使得软件在拥有适应性和灵活性的同时具备较好的稳定性和延续性。

  为了满足开闭原则，需要对系统进行抽象化设计，**抽象化是开闭原则的关键**。可以通过定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行修改，只要增加新的具体类来实现新功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则。

### 里氏代换原则

- 定义：所有引用基类的地方必须能透明地使用其子类的对象。
- 解读：里氏代换原则时实现开闭原则的重要方式之一，在程序中应尽量**使用基类类型来对对象进行定义**，在而运行时再确定其子类类型，用子类对象来替换父类对象。

### 依赖倒转原则

- 定义：高层模块不应该依赖低层模块，他们都应该依赖抽象。抽象不应该细节，细节应该依赖抽象。

- 解读：简单来首，**依赖倒转原则要求面向接口编程，不要面向实现编程**。

  应该使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明，以及数据类型转换，而不要用具体类来做这些事情。

  一个类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到子类中增加的新方法。

- 依赖注入：当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入依赖的对象。

  - 构造注入：通过构造方法传入具体类的对象。
  - 设值注入：通过Setter方法注入具体类的对象。
  - 接口注入：通过在接口声明的业务方法来传入具体类的对象。

  在重构的过程中，一般会同时使用开闭原则、里氏代换原则、依赖倒转原则，**开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段**。

### 接口隔离原则

- 定义：**客户端不应该依赖那些它不需要的接口**。

- 解读：当一个接口太大时需要将它分割成一些更细小的接口，每一个接口应该承担一个相对独立的角色。

  如果把接口理解为一个类型所提供所有方法特征的集合，即逻辑上概念，接口可以理解为角色，也叫“角色隔离原则”。

  如果把接口理解为特定语言（如Java）接口，应当为客户端提供尽可能小的接口，而不要提供大的总接口。；接口应该尽量细化，也要职责单一，同时接口中的方法应该尽量少，每个接口中只包含一个客户端所需的方法即可。这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。

### 合成复用原则

- 定义：优先使用对象组合，而不是通过继承来达到复用的目的。

- 解读：在复用时，**尽量使用组合/聚合关系（关联关系），少用继承**。

  面向对象中可以通过2种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系和通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。

### 迪米特法则

- 定义：每一个软件单位对其他单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位。也被称为**最少知识原则**。

- 解读：迪米特法则要求设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用

  如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。简而言之，就是通过引入一个合理的“第三者”来降低现有对象之间的耦合度。

## 创建型模式

**将对象的创建和使用分离**，让用户再使用对象时无需关注对象的创建细节，**从而降低系统的耦合度**，让设计方案更易于修改和扩展。

### 简单工厂模式

- 定义

  定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常具有共同的父类。

- 结构

![image-20230402203027364](.\设计模式学习.assets\image-20230402203027364.png)

- 实现

- 优点
  - 对象的创建和使用分离
  - 客户端无需知道所创建的具体产品的类的类名，只需要知道具体产品类所对应的参数即可，减少使用者的记忆量
  - 通过引入配置文件，可以在不修改客户端的情况下替换和增加新的具体产品类，提高了系统的灵活性。
  
- 缺点
  - **工厂类集中了所有产品的创建逻辑，职责过重**，一旦不能正常工作，整个系统都要受到影响。
  - 增加了系统中类的个数，增加了系统的复杂度和理解难度。
  - **系统扩展困难，产品类型较多时有可能造成工厂逻辑过于复杂**，不利于系统的扩展和维护。
  - 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
  
- 适用环境
  - **工厂类负责创建的类比较少**。
  
  - 客户端只知道传入工厂类的参数，**对于如何创建对象并不关心**。
  
    

### 工厂方法模式

工厂方法模式是简单工厂模式的延伸，简单工厂模式中工厂类负责所有产品的创建，职责过重，产品类型过多时工厂类逻辑过于复杂；新增产品时，需要修改工厂类逻辑，不符合开闭原则。而工厂方法模式，更好地符合开闭原则，在增加新产品时，不需要对已有系统做修改。

- 定义

  定义一个用于创建对象的接口，但是让子类决定将哪个一个类实例化。**工厂方法模式让一个类的实例化延迟到其子类**。

- 结构

  ![image-20230403224541407](设计模式学习.assets/image-20230403224541407.png)

- 实现

- 优点

  - **用户只需关心所需产品对应的工厂**，无需关心创建细节，甚至无须知道具体产品类的名称。（和简单工厂相比，简单工厂只需要关心创建产品对应的参数）
  - **基于工厂角色和产品角色的多态性设计是工厂方法模式的关键**。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部。**工厂方法模式之所以又被称为多态工厂模式**，正式因为所有的具体工厂类都具有同一抽象父类。
  - 在系统中加入新产品时无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，无须修改其他的具体工厂和具体产品，**只要添加一个具体工厂和具体产品即可**，系统的扩展性变得非常好，完全**符合开闭原则**。

- 缺点

  - 新增产品时需要新增具体产品类和与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度。
  - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。

- 适用环境

  - 客户端不知道它所需要的对象的类。只需要知道对应的工厂即可。具体产品对象的创建由具体工厂类创建，可以将具体工厂类的类名保存在配置文件中。
  - 抽象工厂类通过其子类来指定创建哪个对象。对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定创建哪个具体产品对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象，从而使得系统更容易扩展。



### 抽象工厂模式

在工厂方法模式中，每个具体的工厂只能生产一种具体的产品，但是在抽象工厂模式中一个具体的工厂可以生产一组相关的具体产品，这一组产品称为产品族，产品族中的每一个产品都分属于某一个产品继承等级结构。

工厂方法模式针对的是一个产品等级，而抽象工厂模式面对多个产品等级结构。

产品等级结构：产品的继承结构。

产品族：同一个工厂生产的位于不同产品等级结构中的一组产品。

- 定义

  提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

- 结构

  ![image-20230402214417996](设计模式学习.assets/image-20230402214417996.png)

- 实现

- 优点

  - 抽象工厂模式隔离了具体类的生成，使得客户端并不知道什么被创建。所有的具体工厂都实现了抽象工厂定义的公共接口，因此只需要改变具体工厂的实例就可以在某种程度上改变整个软件系统的行为。
  - 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用如同一个产品族的对象。
  - 增加新的产品族很方便，无须修改已有系统，符合开闭原则。

- 缺点

  增加产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了开闭原则。

  比如再增加一个产品C，则需要修改所有工厂角色，包括抽象工厂类。

- 适用环境

  Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式。
  
  比如皮肤包换肤。
  
  - 一个系统不应该依赖于产品实例如何被创建、组合和表达细节。
  - 系统中有多余一个的产品族，而每次只使用其中某一个产品族。
  - 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
  - 产品等级结构稳定，在设计完成之后不会想系统中增加新的产品等级结构或者删除已有的产品等级结构。



### 建造者模式

- 定义

  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

  复杂对象简单来说就是包含多个成员变量的对象。

- 结构

  ![image-20230403232007312](设计模式学习.assets/image-20230403232007312.png)

- 实现

  - 省略Director

    一般为了简化系统结构，会将指挥者Director和抽象建造者Builder进行合并。

  - 钩子方法引入

    用于精细化控制某个部分是否被创建。

- 优点

- 缺点

- 适用环境

  创建复杂对象。



### 原型模式

- 定义

  使用原型实例指定待创建对象的类型，并通过复制这个原型来创建新的对象。

  **通过克隆复制一个对象。**

- 结构

  ![image-20230403232746998](设计模式学习.assets/image-20230403232746998.png)

- 实现

  Java语言中可以直接用Object.clone实现浅克隆。

  Java语言中可以通过序列化实现深克隆。通过序列化将对象写到流中，再从流中读取出来，可以实现深克隆。

- 优点

- 缺点

- 适用环境

​	

### 介绍模板

- 定义
- 结构
- 实现
- 优点
- 缺点
- 适用环境

  


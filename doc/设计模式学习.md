# 设计模式学习

## 面向对象设计原则

### 单一职责原则

- 定义：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。

- 解读：单一职责原则用来控制类的粒度大小。一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责耦合在一起，当其中一个职责变化时可能会影响其他职责运作，因此需要将这些职责分离。

  **单一职责原则时实现高内聚、低耦合的指导方针**，需要开发人员发现类的不同职责，并将其分离。

### 开闭原则

- 定义：软件实体应当对扩展开放，对修改关闭。

- 解读：开闭原则就是指在软件实体应**尽量在不修改原有代码的情况下进行扩展**。

  如果一个软件设计符合开闭原则，那么在扩展时无须修改现有代码，使得软件在拥有适应性和灵活性的同时具备较好的稳定性和延续性。

  为了满足开闭原则，需要对系统进行抽象化设计，**抽象化是开闭原则的关键**。可以通过定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行修改，只要增加新的具体类来实现新功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则。

### 里氏代换原则

- 定义：所有引用基类的地方必须能透明地使用其子类的对象。
- 解读：里氏代换原则时实现开闭原则的重要方式之一，在程序中应尽量**使用基类类型来对对象进行定义**，在而运行时再确定其子类类型，用子类对象来替换父类对象。

### 依赖倒转原则

- 定义：高层模块不应该依赖低层模块，他们都应该依赖抽象。抽象不应该细节，细节应该依赖抽象。

- 解读：简单来首，**依赖倒转原则要求面向接口编程，不要面向实现编程**。

  应该使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明，以及数据类型转换，而不要用具体类来做这些事情。

  一个类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到子类中增加的新方法。

- 依赖注入：当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入依赖的对象。

  - 构造注入：通过构造方法传入具体类的对象。
  - 设值注入：通过Setter方法注入具体类的对象。
  - 接口注入：通过在接口声明的业务方法来传入具体类的对象。

  在重构的过程中，一般会同时使用开闭原则、里氏代换原则、依赖倒转原则，**开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段**。

### 接口隔离原则

- 定义：**客户端不应该依赖那些它不需要的接口**。

- 解读：当一个接口太大时需要将它分割成一些更细小的接口，每一个接口应该承担一个相对独立的角色。

  如果把接口理解为一个类型所提供所有方法特征的集合，即逻辑上概念，接口可以理解为角色，也叫“角色隔离原则”。

  如果把接口理解为特定语言（如Java）接口，应当为客户端提供尽可能小的接口，而不要提供大的总接口。；接口应该尽量细化，也要职责单一，同时接口中的方法应该尽量少，每个接口中只包含一个客户端所需的方法即可。这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。

### 合成复用原则

- 定义：优先使用对象组合，而不是通过继承来达到复用的目的。

- 解读：在复用时，**尽量使用组合/聚合关系（关联关系），少用继承**。

  面向对象中可以通过2种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系和通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。

### 迪米特法则

- 定义：每一个软件单位对其他单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位。也被称为最少知识原则。

- 解读：迪米特法则要求设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用

  如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。简而言之，就是通过引入一个合理的“第三者”来降低现有对象之间的耦合度。

## 创建型模式

**将对象的创建和使用分离**，让用户再使用对象时无需关注对象的创建细节，**从而降低系统的耦合度**，让设计方案更易于修改和扩展。

### 简单工厂模式

- 定义

  定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常具有共同的父类。

- 结构

![image-20230402203027364](.\设计模式学习.assets\image-20230402203027364.png)

- 实现

- 优点
  - 对象的创建和使用分离
  - 客户端无需知道所创建的具体产品的类的类名，只需要知道具体产品类所对应的参数即可，减少使用者的记忆量
  - 通过引入配置文件，可以在不修改客户端的情况下替换和增加新的具体产品类，提高了系统的灵活性。
  
- 缺点
  - **工厂类集中了所有产品的创建逻辑，职责过重**，一旦不能正常工作，整个系统都要受到影响。
  - 增加了系统中类的个数，增加了系统的复杂度和理解难度。
  - **系统扩展困难，产品类型较多时有可能造成工厂逻辑过于复杂**，不利于系统的扩展和维护。
  - 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
  
- 适用环境
  - **工厂类负责创建的类比较少**。
  
  - 客户端只知道传入工厂类的参数，**对于如何创建对象并不关心**。
  
    

### 工厂方法模式

工厂方法模式是简单工厂模式的延伸，简单工厂模式中工厂类负责所有产品的创建，职责过重，产品类型过多时工厂类逻辑过于复杂；新增产品时，需要修改工厂类逻辑，不符合开闭原则。而工厂方法模式，更好地符合开闭原则，在增加新产品时，不需要对已有系统做修改。

- 定义

  定义一个用于创建对象的接口，但是让子类决定将哪个一个类实例化。**工厂方法模式让一个类的实例化延迟到其子类**。

- 结构

  ![image-20230402214417996](设计模式学习.assets/image-20230402214417996.png)

- 实现

- 优点

  - **用户只需关心所需产品对应的工厂**，无需关心创建细节，甚至无须知道具体产品类的名称。（和简单工厂相比，简单工厂只需要关心创建产品对应的参数）
  - **基于工厂角色和产品角色的多态性设计是工厂方法模式的关键**。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部。**工厂方法模式之所以又被称为多态工厂模式**，正式因为所有的具体工厂类都具有同一抽象父类。
  - 在系统中加入新产品时无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，无须修改其他的具体工厂和具体产品，**只要添加一个具体工厂和具体产品即可**，系统的扩展性变得非常好，完全**符合开闭原则**。

- 缺点

  - 新增产品时需要新增具体产品类和与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度。
  - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。

- 适用环境

  - 客户端不知道它所需要的对象的类。只需要知道对应的工厂即可。具体产品对象的创建由具体工厂类创建，可以将具体工厂类的类名保存在配置文件中。
  - 抽象工厂类通过其子类来指定创建哪个对象。对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定创建哪个具体产品对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象，从而使得系统更容易扩展。



### 抽象工厂模式

- 定义

- 结构

- 实现

- 优点

- 缺点

- 适用环境

  

### 介绍模板

- 定义
- 结构
- 实现
- 优点
- 缺点
- 适用环境

  

